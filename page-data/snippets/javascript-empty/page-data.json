{"componentChunkName":"component---src-templates-blog-post-js","path":"/snippets/javascript-empty/","result":{"data":{"site":{"siteMetadata":{"title":"Developer Notes","author":"Bozhidar Dryanovski"}},"mdx":{"id":"3cf5b246-9a60-5e1e-b399-7bc9348bc569","excerpt":"Often the question is is something empty ? And what is empty really? The quick answer is\nempty is what we decide to be empty. The function below, the standartâ€¦","frontmatter":{"title":"JavaScript: is something empty?","date":"January 13, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript: is something empty?\",\n  \"date\": \"2021-01-13T00:00:00.000Z\",\n  \"slug\": \"/snippets/javascript/is-something-empty\",\n  \"tags\": [\"snippet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Often the question is is something empty ? And what is empty really? The quick answer is\\nempty is what we decide to be empty. The function below, the standart Array and Object are just\\ntested to see if they have entries or keys. But for example boolean and numbers they are not empty\\nthey always have some value, so we decide what value is empty and what not.\"), mdx(\"p\", null, \"So said like that, everything bigger than 0 is not empty, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" are empty.\"), mdx(\"p\", null, \"The method below don\\u2019t handle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Set\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WeakMap\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function empty(value) {\\n  return (\\n    (value === undefined || value === null)\\n    || (typeof value === 'number' && value <= 0)\\n    || (Array.isArray(value) && value.length === 0)\\n    || (typeof value === 'object' && Object.keys(value).length === 0)\\n  )\\n}\\n\")), mdx(\"p\", null, \"In addation to that we need to add some test to make sure everything will\\ncontinue to work:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"describe('empty', () => {\\n  it('should check value and find is it empty or not', () => {\\n    [\\n      [true, []],\\n      [false, [2]],\\n      [true, {}],\\n      [false, { foo: 1 }],\\n      [true, null],\\n      [true, undefined],\\n      [false, true],\\n      [false, false],\\n      [false, 1],\\n      [false, 5],\\n      [true, 0]\\n    ].forEach(([expectedType, value]) => {\\n      expect(empty(value)).toBe(expectedType)\\n    })\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/snippets/javascript-empty/","previous":{"id":"81548a42-28e0-5c56-ae66-bbee8aeb0bdf","fields":{"slug":"/snippets/javascript-npm-registry/"},"frontmatter":{"title":"JavaScript: NPM Registry API query"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript: NPM Registry API query\",\n  \"date\": \"2021-01-13T00:00:00.000Z\",\n  \"slug\": \"/snippets/javascript/npm-registry-api-query\",\n  \"tags\": [\"snippet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Few times in my life I needed to fetch some data from the NPM registry\\nand display some information for a given package, versions, maintainers, last update and so on.\\nAs easy to do that I never try to write something that I could re-use.\"), mdx(\"p\", null, \"So here is it, below is super simple class to do that, and let me write my functions only once. The\\nmethod \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package\"), \" could be re-written with any lib in mind - in this case I use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"axios\"), \" but could\\nbe done in the same way with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fetch\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"node-fetch\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"public package(name: string) {\\n  return fetch(`${this.registry}${name}`)\\n    .then(response => response.json())\\n    .then(response => this.dataWrapper(response.data))\\n}\\n\")), mdx(\"p\", null, \"Or even with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XMLHttpRequest\"), \" if needeed to have less dependencies, a bit more code but still simple.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"public package(name: string) {\\n  return new Promise((resolve, reject) => {\\n    const request = new XMLHttpRequest();\\n    request.open(\\\"GET\\\", `${this.registry}${name}`);\\n    request.responseType = 'json';\\n    request.onload(() => {\\n      if (this.status === 200) {\\n        return resolve(this.response)\\n      }\\n      reject(false)\\n    });\\n    request.send();\\n  })\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dataWrapper\"), \" is a bit overkill, but I often require to fetch this type of the data so why not have\\nthem already defined as methods, and never have to think about it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import axios from \\\"axios\\\";\\n\\nclass NPMQuery {\\n  registry: string = \\\"https://registry.npmjs.org/\\\";\\n\\n  public package(name: string) {\\n    return axios.get(`${this.registry}${name}`)\\n      .then(response => this.dataWrapper(response.data))\\n  }\\n\\n  private dataWrapper(data: Record<any, any>) {\\n    return {\\n      /* Get raw response data - for everything else */\\n      raw: (): Record<string, any> => data,\\n      /* Array of veresions as string */\\n      versions: (): string[] => Object.keys(data.versions),\\n      /* Single version information */\\n      version: (version: string): Record<string, any> => data.versions[version],\\n      /* Array of tags as string */\\n      tags: (): string[] => Object.keys(data['dist-tags'])\\n    }\\n  }\\n}\\n\\nconst npm = new NPMQuery();\\n\\nnpm.package(\\\"@clr/angular\\\").then((r) => {\\n  console.log(\\\"Versions\\\", r.versions());\\n});\\n\")), mdx(\"p\", null, \"As a result we gonna have something  like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"Package {\\n  name: '@clr/angular',\\n  version: '4.0.0',\\n  description: 'Angular components for Clarity',\\n  homepage: 'https://clarity.design/',\\n  keywords: [ 'ng-add', 'clarity', 'angular', 'components' ],\\n  repository: { type: 'git', url: 'git@github.com:vmware/clarity.git' },\\n  peerDependencies: {\\n    '@angular/common': '^10.0.0',\\n    '@angular/core': '^10.0.0',\\n    '@clr/ui': '4.0.0'\\n  },\\n\")), mdx(\"p\", null, \"Having a list of version in the form of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array\"), \" is useful for me in the cases when I need to create\\ndropdowns or list package versions.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"npm.package(\\\"@clr/angular\\\").then((r) => {\\n  console.log(\\\"Versions\\\", r.versions());\\n});\\n\")), mdx(\"p\", null, \"Result could be something like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-bash\"\n  }, \"Versions [\\n  '0.11.0-alpha.1',  '0.11.0-beta.1', '0.11.0-rc.1',   '0.11.0',\\n  '0.11.1',          '0.11.2',        '0.11.2-patch',  '0.11.3',\\n  '0.11.4',          '0.11.5',        '0.11.6',        '0.11.7',\\n  '0.11.7-patch.1',  '0.11.8',        '0.11.9',        '0.11.10',\\n  '0.11.11',         '0.11.12',       '0.11.13',       '0.11.14',\\n  '0.11.15',         '0.11.16',       '0.11.17',       '0.11.18',\\n  '0.11.18-patch.1', '0.12.0-beta.3', '0.11.19',       '0.12.0-beta.4',\\n  '0.12.0-rc.1',     '0.11.20',       '0.11.21',       '0.12.0-rc.2',\\n  '0.12.0',          '0.11.22',       '0.12.1',        '0.11.23',\\n  '0.12.2',          '0.11.24',       '0.12.3',        '0.12.3-patch.1',\\n  '0.12.3-patch.2',  '0.11.25',       '0.12.4',        '0.12.5',\\n  '0.12.6',          '0.11.26',       '0.11.27',       '0.12.7',\\n  '0.11.28',         '0.12.8',        '0.13.0-beta.1', '0.11.29',\\n  '0.12.9',          '0.13.0-beta.2', '0.12.10',       '0.11.30',\\n  '0.12.11',         '0.13.0-rc.1',   '0.12.12',       '0.13.0',\\n  '0.13.1-patch.1',  '0.13.2',        '0.13.3',        '0.13.4',\\n  '0.12.13',         '0.13.5',        '0.11.32',       '0.12.14',\\n  '0.13.6',          '0.11.33',       '0.12.15',       '0.13.7',\\n  '1.0.0-beta.1',    '0.13.8',        '1.0.0-beta.2',  '0.11.34',\\n  '0.12.16',         '0.13.9',        '0.13.10',       '1.0.0-rc.1',\\n  '1.0.0',           '1.0.1',         '1.0.2',         '1.0.3',\\n  '1.0.3-patch',     '1.0.4',         '1.0.5',         '1.1.0',\\n  '2.0.0-beta.1',    '0.13.11',       '1.1.1',         '1.1.2',\\n  '2.0.0-beta.2',    '1.1.3',         '2.0.0-rc.1',    '2.0.0-rc.2',\\n  '2.0.0',           '2.0.1',         '1.1.4',         '2.0.2',\\n  ... 91 more items\\n]\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"e875908d-5bda-5245-b268-00fff5ccad0f","fields":{"slug":"/snippets/javascript-number-rounding/"},"frontmatter":{"title":"JavaScript: Number rounding"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript: Number rounding\",\n  \"date\": \"2021-07-21T00:00:00.000Z\",\n  \"slug\": \"/snippets/javascript/number-rounding\",\n  \"tags\": [\"snippet\", \"math\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So to be able to round a number in JavaScript I found that this is the best and easy way. This way\\nI don\\u2019t have to convert the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" to cut some digits and the transform it back to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n *  @param value - number - Number to round\\n *  @param decimals - number - how many digits after the `.`\\n *  @return number\\n */\\nfunction round(value, decimals) {\\n  return Number(Math.round(`${value}e${decimals}`) + 'e-' + decimals);\\n}\\n\")), mdx(\"p\", null, \"To prove it, here is a test for it\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"describe('Number rounding', () => {\\n  it('should return expected value', () => {\\n    [\\n      [2.1234, 2.12, 2],\\n      [2.125, 2.13, 2],\\n      [2.11111, 2.11, 2],\\n      [2.11115, 2.1112, 4],\\n      [2.123, 2, 0],\\n      [2.123, NaN, 0],\\n      [\\\"2.123\\\", 2.12, 2]\\n    ].forEach(([value, expectedValue, decimals]) => {\\n      expect(round(value, decimals)).toBe(expectedValue)\\n    })\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":["2677188060","3128451518"]}