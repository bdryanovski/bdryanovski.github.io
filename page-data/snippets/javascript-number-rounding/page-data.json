{"componentChunkName":"component---src-templates-blog-post-js","path":"/snippets/javascript-number-rounding/","result":{"data":{"site":{"siteMetadata":{"title":"Developer Notes","author":"Bozhidar Dryanovski"}},"mdx":{"id":"e875908d-5bda-5245-b268-00fff5ccad0f","excerpt":"So to be able to round a number in JavaScript I found that this is the best and easy way. This way\nI don't have to convert the  Number  to  String  to cut someâ€¦","frontmatter":{"title":"JavaScript: Number rounding","date":"July 21, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript: Number rounding\",\n  \"date\": \"2021-07-21T00:00:00.000Z\",\n  \"slug\": \"/snippets/javascript/number-rounding\",\n  \"tags\": [\"snippet\", \"math\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So to be able to round a number in JavaScript I found that this is the best and easy way. This way\\nI don\\u2019t have to convert the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"String\"), \" to cut some digits and the transform it back to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"/**\\n *  @param value - number - Number to round\\n *  @param decimals - number - how many digits after the `.`\\n *  @return number\\n */\\nfunction round(value, decimals) {\\n  return Number(Math.round(`${value}e${decimals}`) + 'e-' + decimals);\\n}\\n\")), mdx(\"p\", null, \"To prove it, here is a test for it\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"describe('Number rounding', () => {\\n  it('should return expected value', () => {\\n    [\\n      [2.1234, 2.12, 2],\\n      [2.125, 2.13, 2],\\n      [2.11111, 2.11, 2],\\n      [2.11115, 2.1112, 4],\\n      [2.123, 2, 0],\\n      [2.123, NaN, 0],\\n      [\\\"2.123\\\", 2.12, 2]\\n    ].forEach(([value, expectedValue, decimals]) => {\\n      expect(round(value, decimals)).toBe(expectedValue)\\n    })\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/snippets/javascript-number-rounding/","previous":{"id":"3cf5b246-9a60-5e1e-b399-7bc9348bc569","fields":{"slug":"/snippets/javascript-empty/"},"frontmatter":{"title":"JavaScript: is something empty?"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript: is something empty?\",\n  \"date\": \"2021-01-13T00:00:00.000Z\",\n  \"slug\": \"/snippets/javascript/is-something-empty\",\n  \"tags\": [\"snippet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Often the question is is something empty ? And what is empty really? The quick answer is\\nempty is what we decide to be empty. The function below, the standart Array and Object are just\\ntested to see if they have entries or keys. But for example boolean and numbers they are not empty\\nthey always have some value, so we decide what value is empty and what not.\"), mdx(\"p\", null, \"So said like that, everything bigger than 0 is not empty, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"false\"), \" are empty.\"), mdx(\"p\", null, \"The method below don\\u2019t handle \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Set\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Map\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"WeakMap\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function empty(value) {\\n  return (\\n    (value === undefined || value === null)\\n    || (typeof value === 'number' && value <= 0)\\n    || (Array.isArray(value) && value.length === 0)\\n    || (typeof value === 'object' && Object.keys(value).length === 0)\\n  )\\n}\\n\")), mdx(\"p\", null, \"In addation to that we need to add some test to make sure everything will\\ncontinue to work:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"describe('empty', () => {\\n  it('should check value and find is it empty or not', () => {\\n    [\\n      [true, []],\\n      [false, [2]],\\n      [true, {}],\\n      [false, { foo: 1 }],\\n      [true, null],\\n      [true, undefined],\\n      [false, true],\\n      [false, false],\\n      [false, 1],\\n      [false, 5],\\n      [true, 0]\\n    ].forEach(([expectedType, value]) => {\\n      expect(empty(value)).toBe(expectedType)\\n    })\\n  })\\n})\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"7d6f14a3-1271-5bc7-86a4-51dfe828252e","fields":{"slug":"/posts/google-extension-and-web-components/"},"frontmatter":{"title":"Build Chrome Extension with Web Components"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Build Chrome Extension with Web Components\",\n  \"date\": \"2021-07-28T00:00:00.000Z\",\n  \"slug\": \"/posts/build-chrome-extension-with-web-components\",\n  \"tags\": [\"post\", \"web-components\", \"typescript\", \"build\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let\\u2019s build a Chrome extension with Web Components. That is what I said last night, and to be honest I never had any idea how to do it. I know that Google Chrome has a way to run complex code inside a isolated sandbox environment, but that is it.\"), mdx(\"p\", null, \"So as always let\\u2019s set some goals and try to make it work.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use WebComponents - going with Lit v2 just because I don\\u2019t want to have to write from scratch a Web Components framework (yet).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Don\\u2019t use any other frameworks or packages\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Keep it super simple and easy to understand\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Build it with a idea that could be used for blueprint for a new project\")), mdx(\"p\", null, \"So I decide to go with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"New Tab\"), \" extension and will go with the most basic and overly developed type of application, \\u201CA todo application\\u201D. But let start with one big disclaimer - this is super minimal and basic form of \\u201CTodo/Task\\u201D application, made for a demo purpose - so lot of corner cases and features will be skipped and left for some other time.\"), mdx(\"h4\", null, \"Create Chrome Manifest\"), mdx(\"p\", null, \"One important thing is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"manifest.json\"), \" file - in other terms this is the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"package.json\"), \" file of Chrome Extensions. Everything that the browser must know about the extension is defined there.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json:title=public/manifest.json\"\n  }, \"{\\n  \\\"manifest_version\\\": 2,\\n  \\\"name\\\": \\\"Experimental New Tab Extension\\\",\\n  \\\"version\\\": \\\"0.0.0\\\",\\n  \\\"description\\\": \\\"Provide playground code\\\",\\n  \\\"icons\\\": {\\n    \\\"16\\\": \\\"static/icon16.png\\\",\\n    \\\"48\\\": \\\"static/icon48.png\\\",\\n    \\\"128\\\": \\\"static/icon128.png\\\"\\n  },\\n  \\\"chrome_url_overrides\\\": {\\n    \\\"newtab\\\": \\\"index.html\\\"\\n  },\\n  \\\"permissions\\\": [\\n    \\\"storage\\\"\\n  ]\\n}\\n\")), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"storage\"), \" permission is something that we gonna need later but I\\u2019m adding it now so we don\\u2019t have to scroll back & front to find it later on. Oh and we will need to have some icons for our extension - this is something that I will leave to you to find.\"), mdx(\"p\", null, \"The key thing here is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome_url_overrides\"), \" and the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"newtab\"), \" key - this will let us overwrite the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome://newtab\"), \" and replace it with our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"index.html\"), \" whatever it does - it\\u2019s up to you. Right now it does nothing and maybe is time to change it.\"), mdx(\"h4\", null, \"Index page\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-html:title=public/index.html\"\n  }, \"<!doctype html>\\n<html>\\n\\n<head lang='en'>\\n  <meta charset='utf-8'>\\n  <meta name='viewport' content='width=device-width'>\\n  <title>New Tab</title>\\n</head>\\n\\n<body>\\n  <app-component></app-component>\\n  <script type=\\\"module\\\" src='bundle.js'></script>\\n</body>\\n\\n</html>\\n\")), mdx(\"p\", null, \"And here again we are going too fast and we are not going to see anything cause we need to do two more things, load our extension and write our first component.\"), mdx(\"p\", null, \"To load the extension Google Chrome have awesome documentation on the topic \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.chrome.com/extensions/getstarted#unpacked\"\n  }, \"here\"), \". So I won\\u2019t cover it today.\"), mdx(\"h4\", null, \"Root component\"), mdx(\"p\", null, \"Let\\u2019s create a simple proof of concept component. And test our new extension.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/main.ts\"\n  }, \"import { LitElement, html } from \\\"lit\\\";\\nimport { customElement } from \\\"lit/decorators.js\\\";\\n\\n@customElement(\\\"app-component\\\")\\nexport default class AppComponent extends LitElement {\\n  render() {\\n    return html`<h1>Howdy!</h1>`;\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"app-component\\\": AppComponent;\\n  }\\n}\\n\")), mdx(\"p\", null, \"If we are sure that our extension is loaded into Chrome, opening new tab will greet us with a nice message of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Hawdy\"), \".\"), mdx(\"p\", null, \"Everything is working and there is nothing more that we could do. The End \\uD83D\\uDC4B.\"), mdx(\"p\", null, \"Oh you are still here, huh? I want a Todo component that could persist the \\u201Ctodos\\u201D in a local storage and show them in a list, let me edit, delete and add new ones. And because I already done this I will start from top to bottom and leave the representation almost for the last step.\"), mdx(\"p\", null, \"I wanted to explore how I could have a root component that could have one goal to keep the data and sync it - something common for a lot of components out there.\"), mdx(\"h4\", null, \"Re-Inventing the wheel - Redux\"), mdx(\"p\", null, \"For my demo needs I don\\u2019t need to have everything that redux has to offer. I need something minimal so I gonna write a cheap version of it.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/store.ts\"\n  }, \"type Reducers<T> = (data: T[], action: { action: string, data: any; }) => T[];\\n\\nexport default class Store<T> {\\n  private key: string;\\n  private data: T[] = [];\\n  private onUpdateFinish = (_data: any) => { };\\n\\n  private reducers: Reducers<T> = (data: T[], _action: { action: string, data: any }) => { return data }\\n\\n  constructor(key: string]) {\\n    this.data = [];\\n    this.key = key;\\n  }\\n\\n  public dispatch(action: string, data: any) {\\n    this.data = this.reducers(this.data, { action, data });\\n    this.sync();\\n  }\\n\\n  public onUpdate(callback: (data: T[]) => void) {\\n    this.onUpdateFinish = callback;\\n\\n    // eslint-disable-next-line no-undef\\n    chrome.storage.sync.get([this.key], (result: Record<string, any>) => {\\n      this.data = result[this.key] || [];\\n      this.sync();\\n    });\\n  }\\n\\n  public reduce(method: Reducers<T>) {\\n    this.reducers = method;\\n  }\\n\\n  sync() {\\n    // eslint-disable-next-line no-undef\\n    chrome.storage.sync.set({ [this.key]: this.data });\\n    this.onUpdateFinish(this.data);\\n  }\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome.storage\"), \" is the one thing that comes with Chrome Extension API, it\\u2019s a wrapper around local storage - but also let us sync between Browsers that have the same account - useful for our feature self.\"), mdx(\"p\", null, \"We gonna create this three basic methods that gonna use inside our wrapper component that we don\\u2019t have at the moment but i\\u2019ll be adding it later on.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reduce\"), \" is the method that will be used to change the reducer of the store. Or simple term - let us transform the data based on some actions. You know Redix way.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onUpdate\"), \" is our trigger it will return the data after we transform it and let us know when we need to do something else like re-render.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dispatch\"), \" that is easy, trigger some data change on the store.\"), mdx(\"p\", null, \"The class will also hide the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome.storage\"), \" calls and will only return the data to us. Everything else is just a nice wrapper and TypeScript magic.\"), mdx(\"p\", null, \"So let\\u2019s define our data model and the reducer.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/reducer.ts\"\n  }, \"export const TASK_INSERT_EVENT = \\\"INSERT\\\";\\nexport const TASK_DROP_EVENT = \\\"DROP\\\";\\nexport const TASK_UPDATE_EVENT = \\\"UPDATE\\\";\\n\\nexport type Task = {\\n  id: string;\\n  title: string;\\n  done: boolean;\\n};\\n\\nexport const reducers = (store: Task[], request: Record<string, any>) => {\\n  switch (request.action) {\\n    case TASK_INSERT_EVENT:\\n      // Add new task on top of the array\\n      store = [request.data, ...store];\\n      break;\\n    case TASK_UPDATE_EVENT:\\n      store = store.map((task: Task) => {\\n        if (task.id === request.data.id) {\\n          return { ...task, ...request.data };\\n        }\\n        return task;\\n      });\\n      break;\\n    case TASK_DROP_EVENT:\\n      store = store.filter((task: Task) => task.id !== request.data.id);\\n      break;\\n    default:\\n      break;\\n  }\\n\\n  return store;\\n\\n}\\n\")), mdx(\"p\", null, \"As additional or let\\u2019s say a safety net we gonna provide a basic polyfill for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"chrome.storage\"), \" so we could even try to test our code outside of the browser.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/chrome-extension.polyfill.ts\"\n  }, \"// @ts-ignore\\nif (chrome?.storage === undefined) {\\n\\n  const methods = {\\n    // @ts-ignore\\n    get: (items: string[], callback: (result: Record<string, any>) => void) => {\\n      // get from local storage\\n      let result: Record<string, any> = {};\\n      for (const key in items) {\\n        result[items[key]] = JSON.parse(window.localStorage.getItem(items[key]) + '');\\n      }\\n      callback(result);\\n    },\\n    // @ts-ignore\\n    set(items: { [key: string]: any; }) {\\n      // set to local storage\\n      for (const key in items) {\\n        window.localStorage.setItem(key, JSON.stringify(items[key]));\\n      }\\n    }\\n  }\\n\\n  // @ts-ignore\\n  chrome = {\\n    storage: {\\n      sync: methods,\\n      local: methods,\\n    }\\n  };\\n}\\n\")), mdx(\"p\", null, \"Now this will work for our development goals, but won\\u2019t let us sync between browsers - and that\\u2019s ok for the moment, we don\\u2019t have a extension that could benefit from that anyway.\"), mdx(\"h4\", null, \"Wrapper\"), mdx(\"p\", null, \"The component that will be used to wrap the store around the task component and handle all the data changes and re-renders. Starting be reuse the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"main.ts\"), \" file.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/main.ts\"\n  }, \"import { LitElement, html } from \\\"lit\\\";\\nimport { customElement } from \\\"lit/decorators.js\\\";\\n\\nimport { reducers, Task } from './reducer';\\n\\nimport Store from \\\"./store\\\";\\n\\n@customElement(\\\"app-component\\\")\\nexport default class AppComponent extends LitElement {\\n\\n  private store!: Store<Task>;\\n\\n  private tasks: Task[] = [];\\n\\n  connectedCallback() {\\n    super.connectedCallback();\\n\\n    this.store = new Store<Task>('tasks', []);\\n    this.store.reduce(reducers)\\n\\n    this.store.onUpdate((data: Task[]) => {\\n      this.tasks = data;\\n      this.requestUpdate();\\n    })\\n  }\\n\\n  render() {\\n    return html`\\n        <h1>Todo App</h1>\\n    `;\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"app-component\\\": AppComponent;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Ok so we have something but, how it works ? \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this.store\"), \" will be our data holder and instance of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Store\"), \" class that we already done above. We gonna attach a function to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"onUpdate\"), \" method that will be called when the data changes and will trigger \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requestUpdate\"), \" method to refresh the view.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"the.store.reduce\"), \" will get the reducers that we defined into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"src/reducer.ts\"), \" and will be used to transform the data.\"), mdx(\"p\", null, \"Everything seems to work but we still don\\u2019t have a todo app at this point. Nothing is creating task and nothing is updating them. So our next goal will be to make the action component that we started all of this.\"), mdx(\"h4\", null, \"Task Component\"), mdx(\"p\", null, \"So for our task component we gonna need to have a property that will accept \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array of Tasks\"), \" from outside and bubble events to our wrapper when we want to change some of them. This way our top component will deal with all data related issues and our simple task component will only solve the view problem.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/task.component.ts\"\n  }, \"import { LitElement, html, svg, unsafeCSS } from \\\"lit\\\";\\nimport { customElement, property } from \\\"lit/decorators.js\\\";\\nimport { classMap } from \\\"lit/directives/class-map.js\\\";\\nimport { repeat } from 'lit/directives/repeat.js';\\n\\nimport styles from './styles.css';\\n\\nimport { TASK_DROP_EVENT, TASK_INSERT_EVENT, Task, TASK_UPDATE_EVENT } from './reducer';\\n\\nexport const TASKS_EVENT = 'DispatchChanges';\\n\\nconst closeIcon = svg`\\n<svg\\n  class=\\\"icon\\\"\\n  fill=\\\"none\\\"\\n  stroke-linecap=\\\"round\\\"\\n  stroke-linejoin=\\\"round\\\"\\n  stroke-width=\\\"2\\\"\\n  viewBox=\\\"0 0 24 24\\\"\\n  stroke=\\\"currentColor\\\"\\n>\\n  <path d=\\\"M6 18L18 6M6 6l12 12\\\"></path>\\n</svg>\\n`;\\n\\n@customElement(\\\"app-tasks\\\")\\nexport default class AppTasks extends LitElement {\\n\\n  static styles = unsafeCSS(styles);\\n\\n  @property()\\n  tasks: Task[] = []\\n\\n  private onEnter(e: KeyboardEvent) {\\n    if (e.key === 'Enter') {\\n      this.createTask();\\n    }\\n  }\\n\\n  private statusChange(id: string, checked: boolean) {\\n    this.dispatchEvent(new CustomEvent(TASKS_EVENT, {\\n      detail: {\\n        action: TASK_UPDATE_EVENT,\\n        data: { id, done: checked }\\n      }\\n    }))\\n  }\\n\\n  private createTask() {\\n    const Entry = this.renderRoot.querySelector('#entry');\\n\\n    // @ts-ignore\\n    if (Entry && Entry.value === '') {\\n      return;\\n    }\\n\\n    this.dispatchEvent(new CustomEvent(TASKS_EVENT, {\\n      detail: {\\n        action: TASK_INSERT_EVENT,\\n        data: {\\n          id: `#${Math.random().toString(36).substr(2, 9)}`,\\n          // @ts-ignore\\n          title: Entry.value,\\n          done: false,\\n        }\\n      }\\n    }));\\n\\n    // @ts-ignore\\n    Entry.value = null;\\n  }\\n\\n  private editTask(id: string, title: string) {\\n    this.dispatchEvent(new CustomEvent(TASKS_EVENT, {\\n      detail: {\\n        action: TASK_UPDATE_EVENT,\\n        data: { id, title }\\n      }\\n    }))\\n  }\\n\\n  private drop(id: string) {\\n    this.dispatchEvent(new CustomEvent(TASKS_EVENT, {\\n      detail: {\\n        action: TASK_DROP_EVENT,\\n        data: { id }\\n      }\\n    }))\\n  }\\n\\n  render() {\\n    return html`\\n        <div class=\\\"container\\\">\\n          <div class=\\\"card\\\">\\n            <div class=\\\"title\\\">Tasks</div>\\n            <div class=\\\"form\\\">\\n              <input id=\\\"entry\\\" type=\\\"text\\\" @keyup=\\\"${this.onEnter}\\\" placeholder=\\\"what is your plan for today\\\" class=\\\"input\\\" />\\n            </div>\\n            <ul class=\\\"tasks\\\">\\n              ${this.tasks &&\\n                repeat(this.tasks, (task) => task.id, (task) => html`\\n                  <li id=\\\"${task.id}\\\" class=\\\"task\\\">\\n                    <div class=\\\"task-content ${classMap({ \\\"task-done\\\": task.done })}\\\">\\n                      <input @change=${(e: any)=> this.statusChange(task.id, e.target.checked)}\\n                      .checked=\\\"${task.done}\\\"\\n                      type=\\\"checkbox\\\"\\n                      />\\n                      <input type=\\\"text\\\" @blur=${(e: any)=> this.editTask(task.id, e.target.value)}\\n                      .value=\\\"${task.title}\\\"\\n                      class=\\\"task-edit\\\"\\n                      />\\n                    </div>\\n                    <button @click=${()=> this.drop(task.id)}>\\n                      ${closeIcon}\\n                    </button>\\n                  </li>`\\n                )\\n                }\\n            </ul>\\n          </div>\\n        </div>\\n    `;\\n  }\\n}\\n\\ndeclare global {\\n  interface HTMLElementTagNameMap {\\n    \\\"app-tasks\\\": AppTasks;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Our component will dispatch events for every action that we need to do and our wrapper component must handle it. Going with custom event is just so I could show how we could do that and don\\u2019t mess with some of already defined events.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// Dispatch Event outside this component\\nthis.dispatchEvent(new CustomEvent(TASKS_EVENT, {\\n  // Use `detail` to pass data\\n  detail: {\\n    // Action for our store\\n    action: TASK_INSERT_EVENT,\\n    data: {\\n      // Generate a random id for every new task\\n      id: GenerateId(),\\n      title: Entry.value,\\n      done: false,\\n    }\\n  }\\n}));\\n\")), mdx(\"p\", null, \"This event will be handle by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"app-component\"), \" and passed inside the store, there it will be added to the store internal copy of the data and in the same time sync with the Chrome internal storage.\"), mdx(\"h4\", null, \"Modify the App Component\"), mdx(\"p\", null, \"Let\\u2019s integrate the two components into our app.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts:title=src/main.ts\"\n  }, \"// Add Task Component\\nimport { TASKS_EVENT } from './task.component';\\n\\n@customElement(\\\"app-component\\\")\\nexport default class AppComponent extends LitElement {\\n\\n  // ...\\n\\n  // Add additional methods to handle events\\n  async firstUpdated() {\\n    const AppTasks = this.renderRoot.querySelector('app-tasks');\\n    AppTasks?.addEventListener(TASKS_EVENT, this.handleChanges.bind(this))\\n  }\\n\\n  private handleChanges(event: any) {\\n    const { action, data } = event.detail;\\n    this.store.dispatch(action, data)\\n  }\\n\\n  // Update the render method\\n  render() {\\n    return html`\\n        <app-tasks .tasks=${this.tasks}></app-tasks>\\n    `;\\n  }\\n}\\n\")), mdx(\"p\", null, \"Now if we render the app we should see our new component working as best friends. Pretty much if this run from the first time - that is a miracle.\"), mdx(\"p\", null, \"The result of all of this is that we have a HOC that will handle all the logic from where the data comes and how the data is modify if needed and let the Task component handle how the data is presented. We gonna have a super basic storage but in the same time a blueprint on how to implement something much more complex.\"), mdx(\"p\", null, \"The how project could be find here in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/bdryanovski/chrome-extension-webcomponent\"\n  }, \"Github Repository\"), \" - feel free to modify and use it as a starting point.\"));\n}\n;\nMDXContent.isMDXComponent = true;"}}},"staticQueryHashes":["2677188060","3128451518"]}